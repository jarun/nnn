#!/usr/bin/env sh

# Description: Terminal based file previewer
#
# Note: This plugin needs a "NNN_FIFO" to work. See man.
#
# Dependencies:
#    - Supports 4 independent methods to preview with:
#        - tmux (>=3.0), or
#        - kitty with allow_remote_control and listen_on set in kitty.conf, or
#        - QuickLook on WSL (https://github.com/QL-Win/QuickLook)
#        - $TERMINAL set to a terminal (it's xterm by default).
#    - less or $PAGER
#    - tree or exa or ls
#    - mediainfo or file
#    - mktemp
#    - unzip
#    - tar
#    - man
#    - optional: bsdtar or atool for additional archive preview
#    - optional: bat for code syntax highlighting
#    - optional: ueberzug, kitty terminal, viu or catimg for images
#    - optional: convert(ImageMagick) for playing gif preview
#    - optional: ffmpegthumbnailer for video thumbnails (https://github.com/dirkvdb/ffmpegthumbnailer)
#    - optional: ffmpeg for audio thumbnails
#    - optional: libreoffce for opendocument/officedocument preview
#    - optional: pdftoppm(poppler) for pdf thumbnails
#    - optional: gnome-epub-thumbnailer for epub thumbnails (https://gitlab.gnome.org/GNOME/gnome-epub-thumbnailer)
#    - optional: fontpreview for font preview (https://github.com/sdushantha/fontpreview)
#    - optional: glow or lowdown for markdown
#    - optional: w3m or lynx or elinks for html
#    - optional: set/export ICONLOOKUP as 1 to enable file icons in front of directory previews with .iconlookup
#                Icons and colors are configureable in .iconlookup
#    - optional: scope.sh file viewer from ranger.
#                To use:
#                1. drop scope.sh executable in $PATH
#                2. set/export $USE_SCOPE as 1
#    - optional: pistol file viewer (https://github.com/doronbehar/pistol).
#                To use:
#                1. install pistol
#                2. set/export $USE_PISTOL as 1
#
# Usage:
#   You need to set a NNN_FIFO path and a key for the plugin with NNN_PLUG,
#   then start `nnn`:
#
#     $ nnn -a
#
#   or
#
#     $ NNN_FIFO=/tmp/nnn.fifo nnn
#
#   Then in `nnn`, launch the `preview-tui-ext` plugin.
#
#   If you provide the same NNN_FIFO to all nnn instances, there will be a
#   single common preview window. If you provide different FIFO path (e.g.
#   with -a), they will be independent.
#
#   The previews will be shown in a tmux split. If that isn't possible, it
#   will try to use a kitty terminal split. And as a final fallback, a
#   different terminal window will be used ($TERMINAL).
#
#   Tmux and kitty users can configure $SPLIT to either "h" or "v" to set a
#   'h'orizontal split or a 'v'ertical split (as in, the line that splits the
#   windows will be horizontal or vertical).
#
#   Kitty users need `allow_remote_control` set to `yes`, and `listen_on` set
#   to e.g. "$TMPDIR/kitty". To customize the window split, `enabled_layouts`
#   has to be set to `all` or `splits` (the former is the default value).
#   This terminal is also able to show images without extra dependencies.
#
# Shell: POSIX compliant
# Authors: Todd Yamakawa, LÃ©o Villeveygoux, @Recidiviste, Mario Ortiz Manero, Luuk van Baal

SPLIT="$SPLIT"  # you can set a permanent split here
TERMINAL="$TERMINAL"  # same goes for the terminal
USE_SCOPE="${USE_SCOPE:-0}"
USE_PISTOL="${USE_PISTOL:-0}"
ICONLOOKUP="${ICONLOOKUP:-0}"
PAGER="${PAGER:-less -P?n -R}"
TMPDIR="${TMPDIR:-/tmp}"
# Consider setting NNN_PREVIEWDIR to $XDG_CACHE_HOME/nnn/previews if you want to keep previews on disk between reboots
NNN_PREVIEWDIR="${NNN_PREVIEWDIR:-$TMPDIR/nnn/previews}"
NNN_PREVIEWWIDTH="${NNN_PREVIEWWIDTH:-1920}"
NNN_PREVIEWHEIGHT="${NNN_PREVIEWHEIGHT:-1080}"

startpreview() {
    NUMPREVIEWTUI="$(($(find "$TMPDIR" -maxdepth 1 -name 'nnn-preview-tui-pagerpid*' 2>/dev/null | wc -l) + 1))"
    PAGERPID="$TMPDIR/nnn-preview-tui-pagerpid.$NUMPREVIEWTUI"
    IMGPID="$TMPDIR/nnn-preview-tui-gifpid.$NUMPREVIEWTUI"
    CURSEL="$TMPDIR/nnn-preview-tui-selection.$NUMPREVIEWTUI"
    FIFO_UEBERZUG="$TMPDIR/nnn-preview-tui-ueberzug-fifo.$NUMPREVIEWTUI"

    [ "$PAGER" = "most" ] && PAGER="less -R"

    if [ -e "${TMUX%%,*}" ] && tmux -V | grep -q '[ -][3456789]\.'; then
        TERMINAL=tmux
    elif [ -n "$KITTY_LISTEN_ON" ]; then
        TERMINAL=kitty
    else
        TERMINAL="${TERMINAL:-xterm}"
    fi

    if [ -z "$SPLIT" ] && [ $(($(tput lines) * 2)) -gt "$(tput cols)" ]; then
        SPLIT='h'
    elif [ "$SPLIT" != 'h' ]; then
        SPLIT='v'
    fi

    if [ "$TERMINAL" = "tmux" ]; then
        # tmux splits are inverted
        if [ "$SPLIT" = "v" ]; then SPLIT="h"; else SPLIT="v"; fi

        tmux split-window -e "NNN_FIFO=$NNN_FIFO" -e "PREVIEW_MODE=1" -e "PAGER=$PAGER" \
            -e "USE_SCOPE=$USE_SCOPE" -e "SPLIT=$SPLIT" -e "USE_PISTOL=$USE_PISTOL" \
            -e "BAT_STYLE=${BAT_STYLE:-numbers}" -e "PAGERPID=$PAGERPID" \
            -e "IMGPID=$IMGPID" -e "CURSEL=$CURSEL" -e "TMPDIR=$TMPDIR" \
            -e "ICONLOOKUP=$ICONLOOKUP" -e "NNN_PREVIEWDIR=$NNN_PREVIEWDIR" \
            -e "NNN_PREVIEWWIDTH=$NNN_PREVIEWWIDTH" -e "NNN_PREVIEWHEIGHT=$NNN_PREVIEWHEIGHT" \
            -e "FIFO_UEBERZUG=$FIFO_UEBERZUG" -e "QLPATH=$2" -d"$SPLIT" "$0" "$1"
    elif [ "$TERMINAL" = "kitty" ]; then
        # Setting the layout for the new window. It will be restored after the
        # script ends.
        kitty @ goto-layout splits >/dev/null

        # Trying to use kitty's integrated window management as the split window.
        # All environmental variables that will be used in the new window must
        # be explicitly passed.
        kitty @ launch --no-response --title "nnn preview" --keep-focus \
            --cwd "$PWD" --env "PATH=$PATH" --env "NNN_FIFO=$NNN_FIFO" \
            --env "PREVIEW_MODE=1" --env "PAGER=$PAGER" --env "TMPDIR=$TMPDIR" \
            --env "USE_SCOPE=$USE_SCOPE" --env "SPLIT=$SPLIT" --env "TERMINAL=$TERMINAL"\
            --env "USE_PISTOL=$USE_PISTOL" --env "BAT_STYLE=${BAT_STYLE:-numbers}" \
            --env "PAGERPID=$PAGERPID" --env "IMGPID=$IMGPID" --env "FIFO_UEBERZUG=$FIFO_UEBERZUG" \
            --env "ICONLOOKUP=$ICONLOOKUP" --env "NNN_PREVIEWDIR=$NNN_PREVIEWDIR" \
            --env "NNN_PREVIEWWIDTH=$NNN_PREVIEWWIDTH" --env "NNN_PREVIEWHEIGHT=$NNN_PREVIEWHEIGHT" \
            --env "CURSEL=$CURSEL" --location "${SPLIT}split" "$0" "$1" >/dev/null
    elif [ -n "$2" ]; then
        QUICKLOOK=1 QLPATH="$2" PREVIEW_MODE=1 "$0" "$1" >/dev/null &
    else
        PAGERPID="$PAGERPID" IMGPID="$IMGPID" CURSEL="$CURSEL" PREVIEW_MODE=1 \
            FIFO_UEBERZUG="$FIFO_UEBERZUG" $TERMINAL -e "$0" "$1" 2>/dev/null &
    fi
}

togglepreview() {
    if exists QuickLook.exe; then
        QLPATH="QuickLook.exe"
    elif exists Bridge.exe; then
        QLPATH="Bridge.exe"
    fi
    if pkill -fx "cat $NNN_FIFO" >/dev/null; then
        if [ -n "$QLPATH" ] && stat "$1" >/dev/null 2>&1; then
            f="$(wslpath -w "$1" 2>&1)" && "$QLPATH" "$f" &
        fi
    else
        startpreview "$1" "$QLPATH"
    fi
}

exists() {
    type "$1" >/dev/null 2>&1
}

fifo_pager() {
    cmd="$1"
    shift

    # We use a FIFO to access $PAGER PID in jobs control
    tmpfifopath="$TMPDIR/nnn-preview-tui-fifo.$$"
    mkfifo "$tmpfifopath" || return

    $PAGER < "$tmpfifopath" &
    printf "%s" "$!" > "$PAGERPID"

    (
        exec > "$tmpfifopath"
        if [ "$cmd" = "pager" ]; then
            if exists bat; then
                bat --terminal-width="$(tput cols)" --decorations=always --color=always \
                    --paging=never --style="${BAT_STYLE:-numbers}" "$@" 2>/dev/null &
            else
                $PAGER "$@" &
            fi
        else
            "$cmd" "$@" &
        fi
    )

    rm "$tmpfifopath"
}

# Binary file: show file info inside the pager
print_bin_info() {
    printf -- "-------- \033[1;31mBinary file\033[0m --------\n"
    if exists mediainfo; then
        mediainfo "$1" 2>/dev/null
    else
        file -b "$1"
    fi
}

handle_mime() {
    case "$2" in
        image/jpg) image_preview "$cols" "$lines" "$1" ;;
        image/gif) generate_preview "$cols" "$lines" "$1" "gif" ;;
        image/*) generate_preview "$cols" "$lines" "$1" "image" ;;
        video/*) generate_preview "$cols" "$lines" "$1" "video" ;;
        audio/*) generate_preview "$cols" "$lines" "$1" "audio" ;;
        application/font*|application/*opentype) generate_preview "$cols" "$lines" "$1" "font" ;;
        */*office*|*/*document*) generate_preview "$cols" "$lines" "$1" "office" ;;
        application/zip) fifo_pager unzip -l "$1" ;;
        text/troff)
            if exists man; then
                fifo_pager man -Pcat -l "$1"
            else
                fifo_pager pager "$1"
            fi ;;
        *) handle_ext "$1" "$3" "$4" ;;
    esac
}

handle_ext() {
    case "$2" in
        epub) generate_preview "$cols" "$lines" "$1" "epub" ;;
        pdf) generate_preview "$cols" "$lines" "$1" "pdf" ;;
        gz|bz2) fifo_pager tar -tvf "$1" ;;
        md) if exists glow; then
                fifo_pager glow -s dark "$1"
            elif exists lowdown; then
                fifo_pager lowdown -Tterm "$1"
            else
                fifo_pager pager "$1"
            fi ;;
        htm|html|xhtml)
            if exists w3m; then
                fifo_pager w3m "$1"
            elif exists lynx; then
                fifo_pager lynx "$1"
            elif exists elinks; then
                fifo_pager elinks "$1"
            else
                fifo_pager pager "$1"
            fi ;;
        7z|a|ace|alz|arc|arj|bz|cab|cpio|deb|jar|lha|lz|lzh|lzma|lzo\
        |rar|rpm|rz|t7z|tar|tbz|tbz2|tgz|tlz|txz|tZ|tzo|war|xpi|xz|Z)
            if exists atool; then
                fifo_pager atool -l "$1"
            elif exists bsdtar; then
                fifo_pager bsdtar -tvf "$1"
            fi ;;
        *) if [ "$3" = "bin" ]; then
               fifo_pager print_bin_info "$1"
           else
               fifo_pager pager "$1"
           fi ;;
    esac
}

preview_file() {
    clear
    # Trying to use pistol if it's available.
    if [ "$USE_PISTOL" -ne 0 ] && exists pistol; then
        fifo_pager pistol "$1"
        return
    fi

    # Trying to use scope.sh if it's available.
    if [ "$USE_SCOPE" -ne 0 ] && exists scope.sh; then
        fifo_pager scope.sh "$1" "$cols" "$lines" "$(mktemp -d)" \
            "True" 2>/dev/null
        return
    fi

    # Use QuickLook if it's available.
    if [ -n "$QUICKLOOK" ]; then
        stat "$1" >/dev/null 2>&1 && f="$(wslpath -w "$1" 2>&1)" && "$QLPATH" "$f" &
        return
    fi

    # Detecting the exact type of the file: the encoding, mime type, and
    # extension in lowercase.
    encoding="$(file -bL --mime-encoding -- "$1")"
    mimetype="$(file -bL --mime-type -- "$1")"
    ext="${1##*.}"
    [ -n "$ext" ] && ext="$(printf "%s" "${ext}" | tr '[:upper:]' '[:lower:]')"
    lines=$(tput lines)
    cols=$(tput cols)

    # Otherwise, falling back to the defaults.
    if [ -d "$1" ]; then
        cd "$1" || return
        if [ "$ICONLOOKUP" -ne 0 ] && [ -f "$(dirname "$0")"/.iconlookup ]; then
            [ "$SPLIT" = h ] && [ "$TERMINAL" != "kitty" ] && BSTR="\n"
            [ "$SPLIT" = v ] && [ "$TERMINAL" = "kitty" ] && BSTR="\n"
            # shellcheck disable=SC2012
            ls -F --group-directories-first | head -n "$((lines - 3))" | "$(dirname "$0")"/.iconlookup -l "$cols" -B "$BSTR" -b " "
        elif exists tree; then
            fifo_pager tree --filelimit "$(find . -maxdepth 1 | wc -l)" -L 3 -C -F --dirsfirst --noreport
        elif exists exa; then
            exa -G --group-directories-first --colour=always 2>/dev/null
        else
            fifo_pager ls -F --group-directories-first --color=always
        fi
    elif [ "${encoding#*)}" = "binary" ]; then
        handle_mime "$1" "$mimetype" "$ext" "bin"
    else
        handle_mime "$1" "$mimetype" "$ext"
    fi
}

generate_preview() {
  if [ -n "$QLPATH" ] && stat "$3" >/dev/null 2>&1; then
        f="$(wslpath -w "$3" 2>&1)" && "$QLPATH" "$f" &
  elif [ ! -f "$NNN_PREVIEWDIR/$3.jpg" ] || [ -n "$(find -L "$3" -newer "$NNN_PREVIEWDIR/$3.jpg")" ]; then
        mkdir -p "$NNN_PREVIEWDIR/${3%/*}"
        case $4 in
            audio) ffmpeg -i "$3" -filter_complex "scale=iw*min(1\,min($NNN_PREVIEWWIDTH/iw\,ih)):-1" "$NNN_PREVIEWDIR/$3.jpg" -y >/dev/null 2>&1 ;;
            epub) gnome-epub-thumbnailer "$3" "$NNN_PREVIEWDIR/$3.jpg" >/dev/null 2>&1 ;;
            font) fontpreview -i "$3" -o "$NNN_PREVIEWDIR/$3.jpg" >/dev/null 2>&1 ;;
            gif) if exists ueberzug && exists convert && [ "$TERMINAL" != "kitty" ]; then
                    if [ ! -d "$NNN_PREVIEWDIR/$3" ]; then
                        mkdir -p "$NNN_PREVIEWDIR/$3"
                        convert -coalesce -resize "$NNN_PREVIEWWIDTH"x"$NNN_PREVIEWHEIGHT"\> "$3" "$NNN_PREVIEWDIR/$3/${3##*/}.jpg"
                    fi
                        while true; do
                            for frame in $(find "$NNN_PREVIEWDIR/$3"/*.jpg | sort -V); do
                                image_preview "$1" "$2" "$frame"
                                sleep 0.1
                            done
                        done &
                        printf "%s" "$!" > "$IMGPID"
                        return
                 else
                    image_preview "$1" "$2" "$3"
                    return
                 fi ;;
            image) convert "$3" -flatten -resize "$NNN_PREVIEWWIDTH"x"$NNN_PREVIEWHEIGHT"\> "$NNN_PREVIEWDIR/$3.jpg" ;;
            office) libreoffice --convert-to jpg "$3" --outdir "$NNN_PREVIEWDIR/${3%/*}" > /dev/null 2>&1
                    filename="$(printf "%s" "${3##*/}" | cut -d. -f1)"
                    mv "$NNN_PREVIEWDIR/${3%/*}/$filename.jpg" "$NNN_PREVIEWDIR/$3.jpg" ;;
            pdf) pdftoppm -jpeg -f 1 -singlefile "$3" "$NNN_PREVIEWDIR/$3" >/dev/null 2>&1 ;;
            video) ffmpegthumbnailer -s0 -i "$3" -o "$NNN_PREVIEWDIR/$3.jpg" >/dev/null 2>&1 || rm "$NNN_PREVIEWDIR/$3.jpg" ;;
        esac
    fi
    if [ -f "$NNN_PREVIEWDIR/$3.jpg" ]; then
        image_preview "$1" "$2" "$NNN_PREVIEWDIR/$3.jpg"
    else
        fifo_pager print_bin_info "$3"
    fi
}

image_preview() {
    clear
    if [ "$TERMINAL" = "kitty" ]; then
        # Kitty terminal users can use the native image preview method although one might consider
        # installing ueberzug and moving the ueberzug clause to the top since it performs alot better.
        kitty +kitten icat --silent --place "$1"x"$2"@0x0 --transfer-mode=stream --stdin=no "$3" &
        printf "%s" "$!" > "$IMGPID"
    elif exists ueberzug; then
        ueberzug_layer "$1" "$2" "$3"
    elif exists catimg; then
        catimg "$3" &
        printf "%s" "$!" > "$IMGPID"
    elif exists viu; then
        viu -t "$3" &
        printf "%s" "$!" > "$IMGPID"
    else
        fifo_pager print_bin_info "$3"
    fi
}

ueberzug_layer() {
    printf '{"action": "add", "identifier": "nnn_ueberzug", "x": 0, "y": 0, "width": "%s", "height": "%s", "scaler": "fit_contain", "path": "%s"}\n' "$1" "$2" "$3" > "$FIFO_UEBERZUG"
}

ueberzug_remove() {
    printf '{"action": "remove", "identifier": "nnn_ueberzug"}\n' > "$FIFO_UEBERZUG"
}

ueberzug_refresh() {
    clear
    kill "$(cat "$IMGPID" 2>/dev/null)" >/dev/null 2>&1
    pkill -P "$$" >/dev/null 2>&1
    pkill -f -n preview-tui-ext >/dev/null 2>&1
    tail --follow "$FIFO_UEBERZUG" | ueberzug layer --silent --parser json &
    printf "\n" > "$NNN_FIFO"
    preview_fifo 2>/dev/null &
    preview_file "$(cat "$CURSEL")"
    wait
}

preview_fifo() {
    # use cat instead of 'exec <' to avoid issues with dash shell
    # shellcheck disable=SC2002
    cat "$NNN_FIFO" |\
    while read -r selection; do
        kill "$(cat "$IMGPID" 2>/dev/null)" >/dev/null 2>&1
        kill "$(cat "$PAGERPID" 2>/dev/null)" >/dev/null 2>&1
        [ "$TERMINAL" != "kitty" ] && exists ueberzug && ueberzug_remove
        preview_file "$selection"
        printf "%s" "$selection" > "$CURSEL"
    done
    kill "$(cat "$IMGPID" 2>/dev/null)" >/dev/null 2>&1
    kill "$(cat "$PAGERPID" 2>/dev/null)" >/dev/null 2>&1
    [ "$TERMINAL" != "kitty" ] && exists ueberzug && ueberzug_remove
    rm "$PAGERPID" "$IMGPID" "$CURSEL" "$FIFO_UEBERZUG" >/dev/null 2>&1
    pkill -P "$$" >/dev/null 2>&1
}

if [ "$PREVIEW_MODE" ]; then
    if [ "$TERMINAL" != "kitty" ] && exists ueberzug; then
        mkfifo "$FIFO_UEBERZUG"
        trap 'ueberzug_refresh; rm "$FIFO_UEBERZUG"' WINCH
        tail --follow "$FIFO_UEBERZUG" | ueberzug layer --silent --parser json &
    fi
    trap 'rm "$PAGERPID" "$IMGPID" "$CURSEL" "$FIFO_UEBERZUG" 2>/dev/null' INT HUP EXIT

    preview_file "$PWD/$1"
    printf "%s" "$PWD/$1" > "$CURSEL" &
    preview_fifo 2>/dev/null &
    wait
else
    if [ ! -r "$NNN_FIFO" ]; then
        clear
        printf "No FIFO available! (\$NNN_FIFO='%s')\nPlease read Usage in preview-tui-ext." "$NNN_FIFO"
        cfg=$(stty -g); stty raw -echo; head -c 1; stty "$cfg"
    elif [ "$KITTY_WINDOW_ID" ] && [ -z "$KITTY_LISTEN_ON" ]; then
        clear
        printf "\$KITTY_LISTEN_ON not set!\nPlease read Usage in preview-tui-ext."
        cfg=$(stty -g); stty raw -echo; head -c 1; stty "$cfg"
    else
        togglepreview "$1" &
    fi
fi
