# Description: Add git status column to detail mode.
#
# Dependencies: libgit2
#
# Authors: @crides, Luuk van Baal

diff --git a/src/nnn.c b/src/nnn.c
index d83d7f6..7940077 100644
--- a/src/nnn.c
+++ b/src/nnn.c
@@ -105,6 +105,7 @@
 #include <wchar.h>
 #include <pwd.h>
 #include <grp.h>
+#include <git2.h>

 #if !defined(alloca) && defined(__GNUC__)
 /*
@@ -244,6 +245,16 @@ typedef unsigned int uint_t;
 typedef unsigned char uchar_t;
 typedef unsigned short ushort_t;
 typedef unsigned long long ulong_t;
+typedef enum {
+	GIT_COLUMN_STATUS_UNMOD = 0,
+	GIT_COLUMN_STATUS_NEW,
+	GIT_COLUMN_STATUS_MODIFIED,
+	GIT_COLUMN_STATUS_DELETED,
+	GIT_COLUMN_STATUS_RENAMED,
+	GIT_COLUMN_STATUS_TYPE_CHANGE,
+	GIT_COLUMN_STATUS_IGNORED,
+	GIT_COLUMN_STATUS_CONFLICTED,
+} git_column_status_t;

 /* STRUCTURES */

@@ -263,6 +274,8 @@ typedef struct entry {
 	uid_t uid; /* 4 bytes */
 	gid_t gid; /* 4 bytes */
 #endif
+	git_column_status_t status_indexed;
+	git_column_status_t status_staged;
 } *pEntry;

 /* Key-value pairs from env */
@@ -362,7 +375,18 @@ typedef struct {
 } session_header_t;
 #endif

+typedef struct {
+	char *path;
+	git_status_t status;
+} simple_git_status_t;
+
+typedef struct {
+	simple_git_status_t *statuses;
+	size_t len;
+} simple_git_statuses_t;
+
 /* GLOBALS */
+simple_git_statuses_t git_statuses;

 /* Configuration, contexts */
 static settings cfg = {
@@ -3464,6 +3488,80 @@ static char *get_kv_val(kv *kvarr, char *buf, int key, uchar_t max, uchar_t id)
 	return NULL;
 }

+static git_column_status_t git_get_indexed_status(const uint32_t status) {
+	if (status & GIT_STATUS_INDEX_NEW)         return GIT_COLUMN_STATUS_NEW;
+	if (status & GIT_STATUS_INDEX_MODIFIED)    return GIT_COLUMN_STATUS_MODIFIED;
+	if (status & GIT_STATUS_INDEX_DELETED)     return GIT_COLUMN_STATUS_DELETED;
+	if (status & GIT_STATUS_INDEX_RENAMED)     return GIT_COLUMN_STATUS_RENAMED;
+	if (status & GIT_STATUS_INDEX_TYPECHANGE)  return GIT_COLUMN_STATUS_TYPE_CHANGE;
+	return GIT_COLUMN_STATUS_UNMOD;
+}
+
+static git_column_status_t git_get_staged_status(const uint32_t status) {
+	if (status & GIT_STATUS_WT_NEW)         return GIT_COLUMN_STATUS_NEW;
+	if (status & GIT_STATUS_WT_MODIFIED)    return GIT_COLUMN_STATUS_MODIFIED;
+	if (status & GIT_STATUS_WT_DELETED)     return GIT_COLUMN_STATUS_DELETED;
+	if (status & GIT_STATUS_WT_RENAMED)     return GIT_COLUMN_STATUS_RENAMED;
+	if (status & GIT_STATUS_WT_TYPECHANGE)  return GIT_COLUMN_STATUS_TYPE_CHANGE;
+	if (status & GIT_STATUS_IGNORED)        return GIT_COLUMN_STATUS_IGNORED;
+	if (status & GIT_STATUS_CONFLICTED)     return GIT_COLUMN_STATUS_CONFLICTED;
+	return GIT_COLUMN_STATUS_UNMOD;
+}
+
+static void print_gitstatus(git_column_status_t status) {
+	switch (status) {
+		case GIT_COLUMN_STATUS_UNMOD:        addch('-' | 0); break;
+		case GIT_COLUMN_STATUS_NEW:          addch('N' | (g_state.oldcolor ? COLOR_PAIR(1) : COLOR_PAIR(C_EXE))); break;
+		case GIT_COLUMN_STATUS_MODIFIED:     addch('M' | (g_state.oldcolor ? COLOR_PAIR(1) : COLOR_PAIR(4))); break;
+		case GIT_COLUMN_STATUS_DELETED:      addch('D' | (g_state.oldcolor ? COLOR_PAIR(1) : COLOR_PAIR(C_UND))); break;
+		case GIT_COLUMN_STATUS_RENAMED:      addch('R' | (g_state.oldcolor ? COLOR_PAIR(1) : COLOR_PAIR(C_CHR))); break;
+		case GIT_COLUMN_STATUS_TYPE_CHANGE:  addch('T' | (g_state.oldcolor ? COLOR_PAIR(1) : COLOR_PAIR(C_HRD))); break;
+		case GIT_COLUMN_STATUS_IGNORED:      addch('I' | 0); break;
+		case GIT_COLUMN_STATUS_CONFLICTED:   addch('U' | (g_state.oldcolor ? COLOR_PAIR(1) : COLOR_PAIR(C_UND))); break;
+	}
+}
+
+static simple_git_statuses_t statuses_from_path(const char *path) {
+	git_repository *repo;
+	git_buf ret = { .ptr = NULL, .asize = 0, .size = 0 };
+	simple_git_statuses_t statuses = { .statuses = NULL, .len = 0 };
+	git_repository_discover(&ret, path, false, NULL);
+	git_repository_open(&repo, ret.ptr);
+	git_buf_dispose(&ret);
+
+	if (repo) {
+		char buf[PATH_MAX];
+		const char *workdir = git_repository_workdir(repo);
+		git_status_list *status_list;
+
+		git_status_list_new(&status_list, repo, NULL);
+		statuses.len = git_status_list_entrycount(status_list);
+		statuses.statuses = malloc(statuses.len * sizeof(simple_git_status_t));
+
+		for (size_t i = 0; i < statuses.len; ++i) {
+			const git_status_entry *status_ent = git_status_byindex(status_list, i);
+			const char *entry_path = status_ent->head_to_index ? status_ent->head_to_index->old_file.path
+					: status_ent->index_to_workdir->old_file.path;
+
+			xstrsncpy(buf, workdir, xstrlen(workdir));
+			statuses.statuses[i].path = abspath(entry_path, buf);
+			statuses.statuses[i].status = status_ent->status;
+		}
+
+		git_status_list_free(status_list);
+		git_repository_free(repo);
+	}
+	return statuses;
+}
+
+static void git_statuses_free(void) {
+	for (size_t i = 0; i < git_statuses.len; ++i)
+		free(git_statuses.statuses[i].path);
+
+	free(git_statuses.statuses);
+	git_statuses.len = 0;
+}
+
 static void resetdircolor(int flags)
 {
 	/* Directories are always shown on top, clear the color when moving to first file */
@@ -3794,6 +3892,11 @@ static void printent(const struct entry *ent, uint_t namecols, bool sel)

 		if (attrs)
 			attroff(attrs);
+
+		if (git_statuses.len) {
+			print_gitstatus(ent->status_indexed);
+			print_gitstatus(ent->status_staged);
+		}
 	}

 	attrs = 0;
@@ -5119,6 +5222,10 @@ static int dentfill(char *path, struct entry **ppdents)
 		attron(COLOR_PAIR(cfg.curctx + 1));
 	}

+	if (git_statuses.len)
+		git_statuses_free();
+	git_statuses = statuses_from_path(path);
+
 #if _POSIX_C_SOURCE >= 200112L
 	posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);
 #endif
@@ -5316,6 +5423,25 @@ static int dentfill(char *path, struct entry **ppdents)
 #endif
 		}

+		if (git_statuses.len) {
+			uint merged_status = 0;
+			char *dentpath = abspath(dentp->name, path);
+
+			for (size_t i = 0; i < git_statuses.len; ++i) {
+				if (dentp->flags & DIR_OR_LINK_TO_DIR) {
+					size_t dentlen = xstrlen(dentpath);
+
+					if ((dentlen <= xstrlen(git_statuses.statuses[i].path)) && is_prefix(git_statuses.statuses[i].path, dentpath, dentlen))
+						merged_status |= git_statuses.statuses[i].status;
+				} else if (!xstrcmp(git_statuses.statuses[i].path, dentpath))
+						merged_status |= git_statuses.statuses[i].status;
+			}
+
+			dentp->status_indexed = git_get_indexed_status(merged_status);
+			dentp->status_staged = git_get_staged_status(merged_status);
+			free(dentpath);
+		}
+
 		++ndents;
 	} while ((dp = readdir(dirp)));

@@ -5834,11 +5960,11 @@ static int adjust_cols(int n)
 #endif
 	if (cfg.showdetail) {
 		/* Fallback to light mode if less than 35 columns */
-		if (n < 36)
+		if (n < 38)
 			cfg.showdetail ^= 1;
 		else {
 			/* 2 more accounted for below */
-			n -= 32;
+			n -= 34;
 		}
 	}

@@ -7712,6 +7838,8 @@ static void cleanup(void)
 		fflush(stdout);
 	}
 #endif
+	git_statuses_free();
+	git_libgit2_shutdown();
 	free(selpath);
 	free(plgpath);
 	free(cfgpath);
@@ -7907,6 +8035,7 @@ int main(int argc, char *argv[])
 		return EXIT_FAILURE;

 	atexit(cleanup);
+	git_libgit2_init();

 	/* Check if we are in path list mode */
 	if (!isatty(STDIN_FILENO)) {
